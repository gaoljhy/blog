前言
=======

`Http` 缓存机制作为 `web` 性能优化的重要手段
`HTTP`报文
===========

`HTTP`报文就是 浏览器 和 服务器 间通信时发送及响应的数据块
    浏览器向服务器请求数据，发送请求`request`报文
    服务器向浏览器返回数据，返回响应`response`报文

报文信息主要分为两部分
    1.包含属性的首部`header`
        附加信息（`cookie`，缓存信息等）与缓存相关的规则信息，均包含在header中
    2.包含数据的主体部分`body`
        `HTTP`请求真正想要传输的部分

缓存规则解析
==========

    第一次请求，然后留存返回内容,一定时间内，下一次请求返回缓存内容

`HTTP`缓存有多种规则，根据是否需要重新向服务器发起请求来分类，

-----------------------

大致分为两大类(`强制缓存，对比缓存`)

- 强制缓存如果生效，不需要再和服务器发生交互
- 对比缓存不管是否生效，都需要与服务端发生交互

> 两类缓存规则可以同时存在，强制缓存优先级高于对比缓存

    执行强制缓存的规则时,如果缓存生效,直接使用缓存,不再执行对比缓存规则

强制缓存
=========

    强制缓存，在缓存数据未失效的情况下可以直接使用缓存数据

浏览器判断缓存数据失效
    在没有缓存数据的时候，浏览器向服务器请求数据时，服务器会将`数据和缓存规则`一并返回
    缓存规则信息包含在响应`header`中。

对于强制缓存来说，响应`header`中会有两个字段来标明失效规则 `Expires/Cache-Control`

> 使用`chrome`的开发者工具，先启用`disk cache`

`From disk cache` 标记为从硬盘缓存

    --------------

> `Expires` 的值为服务端返回的到期时间

即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。
    `Expires` 是`HTTP 1.0`

> 默认浏览器均默认使用`HTTP 1.1`，所以它的作用基本忽略

    到期时间是由服务端生成的，但是客户端时间可能跟服务端时间有误差，这就会导致缓存命中的误差

> `HTTP 1.1` 的版本，使用`Cache-Control` 替代。

`Cache-Control`
    `Cache-Control` 是最重要的规则。
    常见的取值有 `private、public、no-cache、max-age，no-store`，默认为private。
| 选项          | 作用                                                                               |
| ------------- | ---------------------------------------------------------------------------------- |
| `private`     | 客户端可以缓存                                                                     |
| `public`      | 客户端和代理服务器都可缓存（前端模块，可以认为public和private是一样的）            |
| `max-age=xxx` | 缓存的内容将在 xxx 秒后失效                                                        |
| `no-cache`    | 需要使用对比缓存来验证缓存数据（后面介绍）                                         |
| `no-store`    | 所有内容都不会缓存，强制缓存，对比缓存都不会触发（对于前端开发来说，缓存越多越好） |

对比缓存
===========

> 对比缓存，顾名思义，需要进行比较判断是否可以使用缓存。

    1. 浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中
    2. 再次请求数据时，客户端将备份的缓存标识发送给服务器
    3. 服务器根据缓存标识进行判断，判断成功后，返回 `304` 状态码
        表明客户端已经执行了GET，但文件未变化
    4. 通知浏览器, 比较成功，可以使用缓存数据。

在对比缓存生效时，状态码为`304`，并且报文大小和请求时间大大减少。
    原因是通过状态码通知客户端使用缓存，不再需要将报文主体部分返回给客户端

缓存标识的传递在请求`header`和响应`header`间进行传递，

共分为两种标识传递
`Last-Modified`  /  `If-Modified-Since`

- `Last-Modified`：
    服务器在响应请求时，告诉浏览器资源的最后修改时间

- `If-Modified-Since`：
    再次请求服务器时，通过此字段通知服务器 **上次请求**时，服务器所提供的最后修改时间
    用以判定 是否与最后作出更改 的时间 一致

> 1. 服务器收到请求后发现有头`If-Modified-Since` 则与被请求资源的最后修改时间进行比对。
> 2. 若资源的最后修改时间大于`If-Modified-Since`，说明资源又被改动过，则发送新的指定资源内容，返回新页面的状态码200；
> 3. 若资源的最后修改时间小于或等于`If-Modified-Since`，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。

    ------------

`Etag`  /  `If-None-Match`（优先级高于Last-Modified  /  If-Modified-Since）

Etag
==========

> 服务器响应请求时，告诉浏览器 当前资源 在服务器的唯一标识（生成规则由服务器决定）
类似于自定义版本编号

`If-None-Match`：
    再次请求服务器时，通过此字段通知服务器 **浏览器中** 缓存数据的标识id

服务器收到请求后发现有头`If-None-Match` 则与 被请求资源的 唯一标识id 进行比对，

    > 不同，说明资源又被改动过，则发送新的 资源内容，返回新状态码`200`；
    > 相同，说明资源无新修改，则响应`HTTP 304`，告知浏览器继续使用所保存的`cache`

    --------

总结
=====

1. 首先执行强制缓存策略,浏览器判断是否在 服务器提供的缓存时间内
2. 在缓存时间内，直接调用缓存
3. 不在时间内，执行比较缓存策略

4. 比较缓存，通过缓存信息头中的 `Etag`和 `Last-Modified` 请求发送给服务器
5. 经服务器校验，返回`304`状态码 或 新资源内容

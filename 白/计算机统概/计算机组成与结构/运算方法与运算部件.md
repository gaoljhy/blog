1. 运算部件
    1. ALU，选择器，寄存器组， ，移位器
    2. CPU的位数 指定的是 一次最大运算的位数，不只最大内存
    3. 符号位多加一位 ，在开头
        > [0.11]源 = 011  

    4. 补码(正数不变，负数:除符号位.各位取反后，末尾➕1)，反码(正数不变，负数取反)，原码
        >   [1.11]源 = -[0.11]源 = [2-1.11]补 = []
    5. 计算机内存放的是补码
        > 语言中的负数 比 正数取值范围 多一个 ，原因就是补码与程序的误差
    6. 补码加减法
        1. 符号位参加运算
        2. 补码加减以后仍是补码
            1.   (X+Y)补 = X补 + Y补
            2.   (X-Y)补 = X补 + (-Y)补 
                >  在减法中的 `(-Y)`补 指的是 变补 ， Y的补 连带符号位每一位取反 
                规律 : 负原码 变补 不变
                
            > 3补 + -2补  00011 + 11110 00001
            > -3补 + 2补  11101 + 00010  11111
            > (-4-5)补 = -4补 + (-5)补[= 5补]  01100 + 11011  00111 00111
            > (6-(-4))补 = 6补 + -(-4)补[= 4补] 01010 + 11100  00110 01110  
            

        3. carry 进位 overload 溢出 
            > 符号位相同的俩数相加 与 结果的符号位相同为正确，反之为溢出
            1. 结果符号 fs
            2. 符号位进位 Cf
            3. 尾数最高位进位 C
            > Cf 与 C 不一样为溢出 

        4. 乘法运算
            1. 每次用一位乘数*被乘数全部
                1. 定点小数 0. 无小数部分
                2. 定点整数 无整数部分
                3. 1.10101 整数部分 1 符号 -
            2. 分步乘法
                1. 寄存器
                    1. A 设置 位数(被乘数+1) 存放部分积累加和，乘积高位
                    2. B 存放被乘数
                    3. C 最开始存放乘数，后存放乘积低位
                    > 设置双符号位 初值为 A=00.位(X) B=|X| C=|Y|
                2. 操作
                    1. 设置循环次数 Cd = 被乘数的位数 
                    2. `if C[0] = 1 ，A = C.右移(A , B)`  //判断乘数 每一位 是 0 还是 1 
                    3. `if C[0] = 1 ，A = A.右移(1位)`
                    4. `结果 = A + C` 
                    
                    > C.右移(n，m) : n,C=(n+m)/2 
                    > 本质把 `n+m` 的和放在 n 里 , 求和后的 n 右移一位，把最右面被移出的一位 放到 C 的最前面(符号位后)，C 的最后一位扔出去
            3. 补码 `1` 位乘
                > 符号位参与运算
                1. Y 为正:
                    1. AB取双符号为，符号参加运算
                    2. C取单符号位，符号参加移位，已决定最后是否修正
                    3. C末尾设置符加位

            4. 定点除法运算
                1. 除数 > 被除数
                        1. 2 x 余数 - 除数 = 新余数  
                        > 新余数为 正商1 负商0,恢复原余数
                        2. 被除数,余数  除数  商
                        3. 余数和被除数同号
                
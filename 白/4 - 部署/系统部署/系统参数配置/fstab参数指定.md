# fstab 参数指定

> 参考 <https://wiki.archlinux.org/index.php/Fstab#atime>

## 示例

`UUID=f0d9b5f8-24ef-4aba-b3ce-f4bf0a0c231a /               ext4    errors=remount-ro,noatime,data=writeback 0       1`

> 共6列

## 第四列：`parameters`：文件系统的参数

> 只列出一些,并不完全,需要自己查找

|参数|说明|
| :---: | ---- |
Async/sync | I/O 同步或异步进行, 默认为 async
auto/noauto | 在启动时是否自动挂载 类似于是否键入 `mount -a` 命令时自动挂载
rw/ro | 以只读或者读写模式挂载
exec/noexec | 是否允许执行此分区的二进制文件
user/nouser |  是否允许任意用户挂载此文件系统，若无显示定义，隐含启用 `noexec, nosuid, nodev` 参数。
suid/nosuid | 是否允许 SUID 的存在(这一参数通常用于一些特殊任务，使一般用户运行程序时临时提升权限。)
Usrquota | 启动文件系统支持磁盘配额模式
Grpquota | 启动文件系统对群组磁盘配额模式的支持
Defaults | 同事具有 `rw,suid,dev,exec,auto,nouser,async` 等默认参数的设置
|`noatime` | 不更新文件系统上 `inode` 访问记录，可以提升性能(参见 [atime](https://wiki.archlinux.org/index.php/Fstab#atime) 参数)。
|`nodiratime`| 不更新文件系统上的**目录** `inode` 访问记录，可以提升性能(参见 [atime](https://wiki.archlinux.org/index.php/Fstab#atime) 参数)|
|`relatime` |  实时更新 `inode access` 记录|
|`flush` | `vfat` 的选项，更频繁的刷新数据，复制对话框或进度条在全部数据都写入后才消失|

> `realtime` 只有在记录中的访问时间早于当前访问才会被更新。
（与 `noatime` 相似，但不会打断如 `mutt` 或其它程序探测文件在上次访问后是否被修改的进程。），可以提升性能(参见 `atime` 参数)。

----------------------

### `atime` 参数

这个选项是每次访问时都会更新文件属性中的**访问时间**。
> 类似于文件的记录选项,求掉可以**减少磁盘写操作**

Linux 在默认情况下使用`atime`选项，每次在磁盘上读取（或写入）数据时都会产生一个记录。

> 使用 `noatime`, `nodiratime` 或 `relatime` 可以提升磁盘的性能。

> 默认的 `atime` 选项(非 `noatime,relatime `)最大的问题在于
    >> 即使从页面缓存读取文件(从内存而不是磁盘读取)，也会产生更新文件属性中的**访问时间**操作

### noatime && nodiratime

+ 每次读取文件时，`noatime`选项都会完全禁用向驱动器写入文件的**访问时间**操作
> 即不再启用 文件的 **访问时间** 这个选项
    >> 这是为服务器设计的，在桌面使用中意义不大。没有太频繁的读写操作时无需指定

大部分应用程序都能很好工作。只有少数程序如 `Mutt` 需要这些信息。

`Mutt` 的用户应该使用 `relatime` 选项。

+ 使用 `relatime` 选项后，只有文件被修改时才会更新文件的 **访问时间** 

+ `relatime` 是比较好的折衷，`Mutt` 等程序还能工作，但是仍然能够通过减少 **访问时间属性的更新** 提升系统性能。

注意: noatime 已经包含了 nodiratime。不需要同时指定。

---------------

### 文件系统的日志记录方式

Ext3,EXT4 提供三种数据日志记录方式

1. `data=writeback` (不记录日志,最快)
2. `data=ordered`  (默认) 
3. `data=journal` (记录完整日志,最慢)

+ `data=writeback` 方式
    1. `data=writeback`方式下，`ext3`根本不执行任何形式的数据日志记录
    2. 提供给的是和在`XFS，JFS和 ReiserFS`文件系统中找到的类似的日志记录（仅元数据）
    > 这会让最近修改的文件在 *出现意外的重新引导事件* 中被毁坏
    >> 如果不考虑这个缺点, `data=writeback` 方式在大多数情况下应该能够提供最佳的`ext3,ext4`性能。 


+ `data=ordered` 方式
  1. `data=ordered`方式下，`ext3,ext4`只是正式记录元数据
  2. 而在逻辑上将`元数据`和`数据块`分组到称为事务的单个单元中。
  3. 到了将新的元数据写到磁盘上的时候， 首先写的是相关的数据块。
   
    记录部分日志,分成 **元素据** 和 **元数据指定的数据块** , 元数据确保完整性,数据块存放切块后的数据, 此时只记录 **元素据的日志**即可

    > 一般说来`data=ordered` `ext3`文件系统执行的速度比`data=writeback`文件系统执行的速度稍微慢一些，但比对应的完整数据日志记录还是要快出许多。
    >
    > 将数据附加到文件时，`data=ordered`方式提供了`ext3,ext4`完整数据日志记录方式提供的所有完整性保证。
    
    >> 不过，如果正在覆盖某一部分文件，而此时系统崩溃，那么有可能所写的区将包含原始块和在其中散布了更新块的组合。
    >
    >> 这是因为 `data=ordered` 不提供首先覆盖哪一个数据块的保证，因此不能假设只是因为更新了被覆盖的块 `x`，也就更新了被覆盖的块 `x-1`。
   
   `data=ordered`让写操作顺序由硬盘的写高速缓存决定。
   这个限制并不经常具有负面影响，因为附加的文件一般比覆盖的文件更普遍。
   > 出于这个原因，`data=ordered` 方式是对完整数据日志记录的一个很好的更高性能的替代。

+ `data=journal` 方式

    `data=journal` 方式提供了完整数据和元数据日志记录。
    
    1. 所有新数据首先写入日志
    2. 然后再写入它的最终位置
    > 在崩溃情况下，可以重放日志，使数据和元数据处于一致的状态。


### 要指定日志方式，可以使用如下方式：

1. 向`/etc/fstab`的选项节添加适当的字符串
    例如  `data=journal` 
2. 在调用 `mount` 时直接指定 `-o data=journal` 命令行选项。

+ 指定用于根文件系统的数据日志记录方法

    1. `data=ordered`是缺省值，则可以使用名为 `rootflags` 的特殊**内核引导选项**
    2. 要将根文件系统置于完整数据日志记录方式下，则向内核引导选项添加`rootflags=data=journal`
--------------------

### 挂载文件系统错误时的方法

+ `errors=remount-ro`	
    以错误方式重新装入文件系统为只读。

+ `errors=continue`
    发生文件系统错误仍继续。

+ `errors=panic`
    如果发生错误，请发生紧急停止机器。

这些挂载选项会覆盖在`superblock`中的指定的发生错误后的行为,具体设置可使用 `tune2fs`

-------------------

## 第五列：能否被 dump 备份

> 命令作用：`dump` 是一个用来作为备份的命令。通常这个参数的值为 0 或者 1

|参数 | 说明|
|----|-----|
0 | 代表不要做 dump 备份
1 | 代表要每天进行 dump 的操作
2 | 代表不定日期的进行 dump 操作

## 第六列：是否检验扇区

开机的过程中，系统默认会以 `fsck` 检验系统是否为完整（clean）。

|参数 | 说明
|---|-----|
0 | 不要检验
1 | 最早检验（一般根目录会选择）
2 | 1级别检验完成之后进行检验
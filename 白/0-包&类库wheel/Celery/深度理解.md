# 理解

Celery 是一个专注于实时处理和任务调度的分布式任务队列。
所谓任务就是消息，消息中的有效载荷中包含要执行任务需要的全部数据。

## 使用 Celery 的常见场景如下：

1. Web 应用。
   当用户触发的一个操作需要较长时间才能执行完成时，可以把它作为任务交给 Celery 去异步执行，执行完再返回给用户。这段时间用户不需要等待，提高了网站的整体吞吐量和响应时间。

2. 定时任务。
   生产环境经常会跑一些定时任务。假如你有上千台的服务器、上千种任务，定时任务的管理很困难，Celery 可以帮助我们快速在不同的机器设定不同种任务。

3. 同步完成的附加工作都可以异步完成。
   比如发送短信/邮件、推送消息、清理/设置缓存等。

## Celery 还提供了如下的特性：

1. 方便地查看定时任务的执行情况，比如执行是否成功、当前状态、执行任务花费的时间等。

2. 可以使用功能齐备的管理后台或者命令行添加、更新、删除任务。

3. 方便把任务和配置管理相关联。

4. 可选多进程、Eventlet 和 Gevent 三种模式并发执行。

5. 提供错误处理机制。

- 提供多种任务原语，方便实现任务分组、拆分和调用链。
- 支持多种消息代理和存储后端。

---

## Celery 的架构

Celery 包含如下组件：

1. Celery Beat：任务调度器，`Beat` 进程会读取配置文件的内容，周期性地将配置中到期需要执行的任务发送给任务队列。

2. `Celery Worker`：执行任务的消费者，通常会在多台服务器运行多个消费者来提高执行效率。

3. `Broker`：消息代理，或者叫作消息中间件，接受任务生产者发送过来的任务消息，存进队列再按序分发给任务消费方（通常是消息队列或者数据库）。

4. `Producer`：调用了 `Celery` 提供的 API、函数或者装饰器而产生任务并交给任务队列处理的都是任务生产者。

5. `Result Backend`：任务处理完后保存状态信息和结果，以供查询。
   `Celery` 默认已支持 `Redis`、`RabbitMQ`、`MongoDB`、`Django ORM`、`SQLAlchemy` 等方式。

### Celery 的架构图

![Framework](./Framework.png)

### Celery 序列化

在客户端和消费者之间传输数据需要序列化和反序列化

![序列化](./序列化.jpg)

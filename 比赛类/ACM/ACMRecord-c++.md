## 题意理解及判定过程

1. `ACM`中指定有`test`种情况，代表的是，只有这`test`个数据，做完这些就完了

2. 每一道题，都存在中止情况，
> 一般都会以文件形式输入，`<` ,所以，此时中止符为`EOF`

而检测是否正确就是实时匹配，文件是否一致

## 常见注意点

1. 在外部定义变量，可定义较大数组，vector

2. 使用同一变量时，一定要在下一次 **循环情况** 中记得初始化

3. 标准化 `test case`格式
    ```
    int test,cas = 1;
    cin >> test ; 
    while(test--){
        ....
        cout << "Case " << cas++ << ":" << endl ;
        
        ....
        ....
        //输出结果
        if(test > 0){
            cout << endl;
            //最后的格式化输出
        }
    }
    ```

4. `vector` 的标准 `get`输入
    ```
    int N = 0;
    cin >> N ;
    vec.resize(N,<value>);
    for(int i = 0 ; i < vec.size() ;i++ ){
        cin >> vec[i];
    }
    ```
5. 一般通用的规则是(想想自己写会怎么写)

    `size()` 结构都是从 `1` 开始计数<br>
    其他 `删除，添加，查找` 得到的或者提交的相对位置数 都是以`0`开始计数
    
    在表达连续一段值的时候 ：<br/>
    参数如果为绝对位置(如:`str.begin()~str.end()`)
    俩个参数都应为绝对位置<br>
    如果为数值类型的相对位置(常用) ， 参数传递为 **初始所在位置下标** ， **执行操作的长度** ，此时`front()` ,`back()`常用
---


-----
## 失误记录
1. 运算优先级没有记清楚<br/>
    以防万一，能加`()`的 都加
    ```
    liu = qian + (A[j] - '0' + B[j] - '0') % 10;<br/>
    liu = (qian + (A[j] - '0' + B[j] - '0') )% 10;
    ```
    ```
    qian = (A[j] - '0' + B[j] - '0') / 10;<br/>
    qian = qian + (A[j] - '0' + B[j] - '0') / 10;<br/>
    qian = (qian + (A[j] - '0' + B[j] - '0')) / 10;
    ```
2. 数值比较中，初始化的数据<br>
    标准做法是: `before = 给出的数据中的第一个数`
    ```
    比较大小，有 N 个数，每个数介于 -1000 到 1000 之间 ，取出其中最大的
    上一次比较的数据before 与 这一次比较的数据now 进行比较

    初始化 before 时 ，千万不能以 0  来定义，如果 N 个数，都是负数，那结果，一定是错误的

    ```

3. 递归转循环 ,最简单，从头算起 ,用数组运算代替函数
    ```
    f(1) = 1, f(2) = 1, f(n) = (A * f(n - 1) + B * f(n - 2)) mod 7.
    
    num[1] = 1 ;num[2] =1;
    for(int i =3 ; i < n ; i++){
        num[i] = (A * num[i-1] + B * num[i-2] ) % 7 ;
    }
    ```

4. 内存超限
    
    `vector` 的 `clear` 多次使用 ，所有使用过的内存都会算在其中 ，因为是从堆里面开辟出来 <br>
    此时为了节省内存 ，可使用**大数组** ，或固定长度 的 `vector` ,以保证 不开辟新的空间
    
----
## 附件

[**ASCILL**表](https://github.com/gaoljhy/blog/blob/master/img-%E9%80%9A%E7%94%A8%E5%90%88%E9%9B%86/Ascill.jpg?raw=true)

